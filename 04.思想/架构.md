
# 架构与编程的区别：
- 架构设计的关键思维是判断和取舍，程序设计的关键思维是逻辑和实现。

# 架构是什么
- 需要先梳理几个有关系而又相似的概念，包括：系统与子系统、模块与组件、框架与架构。

## 系统与子系统
### 系统
- 系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。

- 关键内容：
1. 关联：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。
   例如，把一个发动机和一台 PC 放在一起不能称之为一个系统，把发动机、底盘、轮胎、车架组合起来才能成为一台汽车。
2. 规则：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。
   例如，汽车发动机负责产生动力，然后通过变速器和传动轴，将动力输出到车轮上，从而驱动汽车前进。
3. 能力：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。
   例如，汽车能够载重前进，而发动机、变速器、传动轴、车轮本身都不具备这样的能力。

### 子系统
- 子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。
  其实子系统的定义和系统定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统。
  按照这个定义，系统和子系统比较容易理解。
- 我们以微信为例来做一个分析。
1. 微信本身是一个系统，包含聊天、登录、支付、朋友圈等子系统。
2. 朋友圈这个系统又包括动态、评论、点赞等子系统。
3. 评论这个系统可能又包括防刷子系统、审核子系统、发布子系统、存储子系统。
4. 评论审核子系统不再包含业务意义上的子系统，而是包括各个模块或者组件，这些模块或者组件本身也是另外一个维度上的系统。
   例如，MySQL、Redis 等是存储系统，但不是业务子系统。

## 模块与组件
- 软件模块（Module）是一套一致而互相有紧密关连的软件组织。
  它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。
  模块的接口表达了由该模块提供的功能和调用它时所需的元素。
  模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。
- 软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。
- 模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。

从逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。
划分模块的主要目的是职责分离；划分组件的主要目的是单元复用。
其实，“组件”的英文 component 也可翻译成中文的“零件”一词，“零件”更容易理解一些，“零件”是一个物理的概念，并且具备“独立且可替换”的特点。

假设我们要做一个学生信息管理系统，这个系统从逻辑的角度来拆分，可以分为“登录注册模块”“个人信息模块”“个人成绩模块”；
从物理的角度来拆分，可以拆分为 Nginx、Web 服务器、MySQL 等组件。

## 框架与架构
- 软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，
  也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。
1. 框架是组件规范：例如，MVC 就是一种最常见的开发规范，类似的还有 MVP、MVVM、J2EE 等框架。
2. 框架提供基础功能的产品：例如，Spring MVC 是 MVC 的开发框架，除了满足 MVC 的规范，Spring 提供了很多基础功能来帮助我们实现功能，包括注解（@Controller 等）、Spring Security、Spring JPA 等很多基础功能。

- 软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。

框架关注的是“规范”，架构关注的是“结构”。


# 重新定义架构
- 软件架构指软件系统的顶层结构。
1. “系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体”。
2. 系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。
3. 维基百科定义的架构用到了“基础结构”这个说法，我改为“顶层结构”，可以更好地区分系统和子系统，避免将系统架构和子系统架构混淆在一起导致架构层次混乱。


# 架构设计的目的
- 架构设计的主要目的是为了解决软件系统复杂度带来的问题。

- 整个软件技术发展的历史，其实就是一部与“复杂度”斗争的历史，架构的出现也不例外。架构是为了应对软件系统复杂度而提出的一个解决方案。
- 架构即(重要)决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体(人，财，物，时间，事情等)。
- 架构无优劣，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。


# 复杂度的来源
## 复杂度的来源之一高性能
- 单机 -> 多机 -> 集群
## 复杂度的来源之一高可用
- 程序“无中断”，即防止断电、断网、升级、机器故障等问题导致服务中断。
- 高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。
- 计算高可用: 论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的。即数据多个备份来保证(多主多备)
- 存储高可用: 存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。
## 复杂度的来源之一可扩展性
- 正确预测变化、完美封装变化。
- 预测变化的复杂性在于：不能每个设计点都考虑可扩展性。不能完全不考虑可扩展性。所有的预测都存在出错的可能性。
## 复杂度来源：低成本、安全、规模
- 低成本:减少服务器数量、减少流量消耗等(往往需要技术创新，或者采用新技术)
- 安全: 一类是功能上的安全(堵上漏洞)，一类是架构上的安全(防止暴力攻击)。
- 规模: 1. 量变引起质变。功能越来越多，导致系统复杂度指数级上升。 2. 数据越来越多，系统复杂度发生质变。


# 架构设计三原则
## 合适原则
- 合适优于业界领先
- 没那么多人，却想干那么多活，是失败的第一个主要原因。
- 没有那么多积累，却想单纯靠拍脑袋或者头脑风暴能迎接那么多挑战和踩坑，是失败的第二个主要原因。
- 没有那么极端的业务场景，却幻想设计出极端领先的方案，是失败的第三个主要原因。
- 业界领先的方案其实都是“逼”出来的！“业务”发展到一定阶段，量变导致了质变，出现了新的问题，已有的方式已经不能应对，通过创新和尝试，才有了业界领先的方案。
## 简单原则
- 简单优于复杂
1. 结构的复杂性
- 组成系统的组件数量越多，这些组件之间的关系也更加复杂。
- 组件越多，就越有可能其中某个组件出现故障。
- 定位一个复杂系统中的问题总是比简单系统更加困难。
2. 逻辑的复杂性
- “降低组件数量”，使系统结构简化，但会增加单个组件的逻辑复杂性。如果某个组件的逻辑太复杂，一样会带来各种问题。
- 太复杂的单个组件，多人代码合并、版本升级频繁、一个bug影响全局，各种问题也随之增多。
## 演化原则
- 演化优于一步到位
- 软件架构需要根据业务发展不断变化
- 软件架构设计其实更加类似于大自然“设计”一个生物，通过演化让生物适应环境，逐步变得更加强大

